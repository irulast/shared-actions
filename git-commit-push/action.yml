name: 'Git Commit and Push'
description: 'Commit changes and push to repository (useful for GitOps workflows)'
author: 'irulast'

inputs:
  message:
    description: 'Commit message'
    required: true
  files:
    description: 'Files to add (space-separated, or "." for all)'
    required: false
    default: '.'
  author-name:
    description: 'Git author name'
    required: false
    default: 'GitHub Actions'
  author-email:
    description: 'Git author email'
    required: false
    default: 'actions@github.com'
  branch:
    description: 'Branch to push to (leave empty for current branch)'
    required: false
    default: ''
  force:
    description: 'Force push'
    required: false
    default: 'false'
  skip-if-empty:
    description: 'Skip commit if no changes'
    required: false
    default: 'true'

outputs:
  committed:
    description: 'Whether a commit was made'
    value: ${{ steps.commit.outputs.committed }}
  sha:
    description: 'Commit SHA (if committed)'
    value: ${{ steps.push.outputs.sha }}

runs:
  using: 'composite'
  steps:
    - name: Configure git
      shell: sh
      run: |
        git config user.name "${{ inputs.author-name }}"
        git config user.email "${{ inputs.author-email }}"

    - name: Add and commit
      id: commit
      shell: sh
      run: |
        # Add files
        git add ${{ inputs.files }}

        # Check for changes
        if git diff --cached --quiet; then
          echo "No changes to commit"
          if [ "${{ inputs.skip-if-empty }}" = "true" ]; then
            echo "committed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi

        # Commit
        git commit -m "${{ inputs.message }}"
        echo "committed=true" >> $GITHUB_OUTPUT

    - name: Push with retry
      id: push
      if: steps.commit.outputs.committed == 'true'
      shell: sh
      run: |
        BRANCH="${{ inputs.branch }}"
        if [ -z "$BRANCH" ]; then
          BRANCH=$(git rev-parse --abbrev-ref HEAD)
        fi

        # Handle detached HEAD (common in CI)
        if [ "$BRANCH" = "HEAD" ]; then
          # Try to get branch from GITHUB_REF
          if [ -n "$GITHUB_REF" ]; then
            BRANCH=$(echo "$GITHUB_REF" | sed 's|refs/heads/||')
          else
            echo "Error: Cannot determine branch name"
            exit 1
          fi
        fi

        FORCE_FLAG=""
        if [ "${{ inputs.force }}" = "true" ]; then
          FORCE_FLAG="--force"
        fi

        # Store the files we want to commit (for re-applying if needed)
        FILES="${{ inputs.files }}"
        COMMIT_MSG="${{ inputs.message }}"

        MAX_RETRIES=5
        RETRY_COUNT=0

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if git push origin "HEAD:$BRANCH" $FORCE_FLAG 2>&1; then
            echo "Push successful"
            echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
            exit 0
          fi

          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "Push failed (attempt $RETRY_COUNT of $MAX_RETRIES)"

          if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
            echo "Max retries reached, failing"
            exit 1
          fi

          echo "Fetching latest changes and re-applying our changes..."

          # Save our changed files to a temp location
          mkdir -p /tmp/git-commit-push-files
          for file in $FILES; do
            if [ -f "$file" ]; then
              # Create directory structure in temp
              mkdir -p "/tmp/git-commit-push-files/$(dirname "$file")"
              cp "$file" "/tmp/git-commit-push-files/$file"
              echo "Saved: $file"
            fi
          done

          # Fetch and reset to remote
          git fetch origin "$BRANCH"
          git reset --hard "origin/$BRANCH"

          # Re-apply our saved files
          for file in $FILES; do
            if [ -f "/tmp/git-commit-push-files/$file" ]; then
              # Create directory structure if needed
              mkdir -p "$(dirname "$file")"
              cp "/tmp/git-commit-push-files/$file" "$file"
              echo "Restored: $file"
            fi
          done

          # Clean up temp files
          rm -rf /tmp/git-commit-push-files

          # Stage and commit
          git add $FILES

          # Check if there are actually changes to commit
          if git diff --cached --quiet; then
            echo "No changes after re-applying (files already match remote)"
            echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
            exit 0
          fi

          git commit -m "$COMMIT_MSG"
          echo "Re-committed changes, retrying push..."

          sleep 1
        done