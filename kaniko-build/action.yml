name: 'Kaniko Build'
description: 'Build and push Docker images using Kaniko (daemonless, secure)'
author: 'irulast'

inputs:
  context:
    description: 'Build context path'
    required: false
    default: '.'
  dockerfile:
    description: 'Path to Dockerfile'
    required: false
    default: 'Dockerfile'
  destination:
    description: 'Image destination(s), one per line (e.g., registry.example.com/image:tag)'
    required: true
  build-args:
    description: 'Build arguments (one per line, format: KEY=VALUE)'
    required: false
    default: ''
  cache:
    description: 'Enable layer caching'
    required: false
    default: 'true'
  cache-repo:
    description: 'Cache repository (e.g., registry.example.com/cache/image)'
    required: false
    default: ''
  push:
    description: 'Push the image to registry'
    required: false
    default: 'true'
  kaniko-image:
    description: 'Kaniko executor image'
    required: false
    default: 'gcr.io/kaniko-project/executor:latest'
  extra-args:
    description: 'Additional Kaniko arguments'
    required: false
    default: ''

outputs:
  digest:
    description: 'Image digest'
    value: ${{ steps.build.outputs.digest }}

runs:
  using: 'composite'
  steps:
    - name: Build with Kaniko
      id: build
      shell: bash
      run: |
        set -o pipefail

        # Debug: Check if docker config is mounted
        echo "=== Debug: Checking Kaniko Docker Config ==="
        echo "DOCKER_CONFIG env var: ${DOCKER_CONFIG:-NOT SET}"
        echo "Contents of /kaniko/.docker:"
        ls -la /kaniko/.docker/ 2>/dev/null || echo "/kaniko/.docker not found"
        if [ -f /kaniko/.docker/config.json ]; then
          echo "config.json exists, checking content (credentials redacted):"
          cat /kaniko/.docker/config.json | sed 's/"password":"[^"]*"/"password":"***"/g' | sed 's/"auth":"[^"]*"/"auth":"***"/g'
        else
          echo "WARNING: /kaniko/.docker/config.json not found!"
        fi
        echo ""
        echo "Setting DOCKER_CONFIG explicitly..."
        export DOCKER_CONFIG=/kaniko/.docker
        echo "=== End Debug ==="
        echo ""

        # Build Kaniko arguments
        KANIKO_ARGS="--context=${{ inputs.context }} --dockerfile=${{ inputs.dockerfile }}"

        # Add destinations (supports multiple, one per line)
        # Write to temp file to handle multiline input
        printf '%s\n' "${{ inputs.destination }}" > /tmp/destinations.txt
        while IFS= read -r dest || [ -n "$dest" ]; do
          dest=$(printf '%s' "$dest" | tr -d '[:space:]')
          if [ -n "$dest" ]; then
            KANIKO_ARGS="$KANIKO_ARGS --destination=$dest"
          fi
        done < /tmp/destinations.txt

        # Add build args
        BUILD_ARGS='${{ inputs.build-args }}'
        if [ -n "$BUILD_ARGS" ]; then
          printf '%s\n' "$BUILD_ARGS" > /tmp/buildargs.txt
          while IFS= read -r arg || [ -n "$arg" ]; do
            if [ -n "$arg" ]; then
              KANIKO_ARGS="$KANIKO_ARGS --build-arg=$arg"
            fi
          done < /tmp/buildargs.txt
        fi

        # Cache settings
        if [ "${{ inputs.cache }}" = "true" ]; then
          KANIKO_ARGS="$KANIKO_ARGS --cache=true"
          if [ -n "${{ inputs.cache-repo }}" ]; then
            KANIKO_ARGS="$KANIKO_ARGS --cache-repo=${{ inputs.cache-repo }}"
          fi
        fi

        # Push setting
        if [ "${{ inputs.push }}" = "false" ]; then
          KANIKO_ARGS="$KANIKO_ARGS --no-push"
        fi

        # Extra arguments
        if [ -n "${{ inputs.extra-args }}" ]; then
          KANIKO_ARGS="$KANIKO_ARGS ${{ inputs.extra-args }}"
        fi

        # Output the command for debugging
        echo "Kaniko command: /kaniko/executor $KANIKO_ARGS"

        # Run Kaniko
        /kaniko/executor $KANIKO_ARGS | tee /tmp/kaniko-output.txt

        # Extract digest from output (POSIX-compatible)
        DIGEST=$(grep 'digest: sha256:' /tmp/kaniko-output.txt | tail -1 | sed 's/.*digest: //')
        echo "digest=$DIGEST" >> $GITHUB_OUTPUT